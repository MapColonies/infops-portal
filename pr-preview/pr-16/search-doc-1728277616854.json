{"searchDocs":[{"title":"Guides","type":0,"sectionRef":"#","url":"/docs/guides/","content":"Guides","keywords":"","version":"Next"},{"title":"Knowledge Base","type":0,"sectionRef":"#","url":"/docs/knowledge-base/","content":"Knowledge Base","keywords":"","version":"Next"},{"title":"From Zero to Hero","type":0,"sectionRef":"#","url":"/docs/guides/config-management/zero-to-hero","content":"","keywords":"","version":"Next"},{"title":"Assumptionsâ€‹","type":1,"pageTitle":"From Zero to Hero","url":"/docs/guides/config-management/zero-to-hero#assumptions","content":" This guide assumes that you have an already existing service based on the MapColonies boilerplate repo, and basic knowledge of JSON Schema. If needed you can read and learn about JSON Schema in the following link: https://json-schema.org/understanding-json-schema.  It is also recommended to read the schemas package readme.  ","version":"Next","tagName":"h3"},{"title":"What is Config Management?â€‹","type":1,"pageTitle":"From Zero to Hero","url":"/docs/guides/config-management/zero-to-hero#what-is-config-management","content":" Config Management is the complete solution to manage all the configuration needs of MapColonies. It's intended to support the system in all stages from early development to production.  Config management has the following parts:  schemas - Contains the JSON Schemas that define all the configsconfig-server - Server for managing all the configurationsconfig - NPM package for using config management with your NodeJS serviceconfig-ui - UI for interacting with the config server      ","version":"Next","tagName":"h2"},{"title":"Motivationâ€‹","type":1,"pageTitle":"From Zero to Hero","url":"/docs/guides/config-management/zero-to-hero#motivation","content":" The MapColoniesâ„¢ Config Management system provides a centralized solution for managing all service configurations. This system ensures a single source of truth, simplifying configuration management. It also validates configurations against a JSON Schema, guaranteeing their correctness. Additionally, schema validation ensures that all configurations are strongly typed, enabling seamless integration with your code.  ","version":"Next","tagName":"h2"},{"title":"Before we startâ€‹","type":1,"pageTitle":"From Zero to Hero","url":"/docs/guides/config-management/zero-to-hero#before-we-start","content":" In general, the implementation of the MapColoniesâ„¢ Config Management system consists of the following steps:  Work environment setup.Define a JSON Schema for your service configuration.Validating that the schema and the generated types are correct.Integrating the schema with your service. Below each step is explained in detail.  ","version":"Next","tagName":"h2"},{"title":"Initialize the work environmentâ€‹","type":1,"pageTitle":"From Zero to Hero","url":"/docs/guides/config-management/zero-to-hero#initialize-the-work-environment","content":" Clone the schemas repo into your own machine:  git clone git@github.com:MapColonies/schemas.git   Change the working directory.  cd schemas   Install the dependencies.  npm install   Create a new branch for your schema.  git branch &lt;my-branch-name&gt;   Open the repository in your editor (vscode for this guide).  code .   Create a file for your schema under the schemas folder. The directory hierarchy represents the ID of the schema. For example, a common schema that handles redis configuration might be under schemas/common/redis/v1.schema.json and its id will be https://mapcolonies.com/common/redis/v1. The file name is based on the order of the schema. If it's the first one, the name should be v1.schema.json, otherwise it should be the next number in order.  ","version":"Next","tagName":"h2"},{"title":"Creating the schemaâ€‹","type":1,"pageTitle":"From Zero to Hero","url":"/docs/guides/config-management/zero-to-hero#creating-the-schema","content":" Start by filling all the metadata for your JSON Schema. The more metadata you fill, it will be easier to understand and use your schema.  schemas/my-domain/my-schema/v1.schema.json { &quot;$id&quot;: &quot;https://mapcolonies.com/my-domain/my-schema/v1&quot;, &quot;type&quot;: &quot;object&quot;, &quot;title&quot;: &quot;myDomainMySchemaV1&quot;, &quot;description&quot;: &quot;My domain's schema&quot; }   Create your schema content. Use the official JSON Schema docs, The tips page and check other schemas in the repo for reference.  schemas/my-domain/my-schema/v1.schema.json { &quot;$id&quot;: &quot;https://mapcolonies.com/my-domain/my-schema/v1&quot;, &quot;type&quot;: &quot;object&quot;, &quot;title&quot;: &quot;myDomainMySchemaV1&quot;, &quot;description&quot;: &quot;My domain's schema&quot;, &quot;properties&quot;: { &quot;id&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;The unique identifier for the entity&quot; }, &quot;name&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;The name of the entity&quot; }, &quot;age&quot;: { &quot;type&quot;: &quot;integer&quot;, &quot;description&quot;: &quot;The age of the entity&quot;, &quot;x-env-value&quot;: &quot;ENTITY_AGE&quot; }, &quot;isAlive&quot;: { &quot;type&quot;: &quot;boolean&quot;, &quot;description&quot;: &quot;Is the entity alive&quot;, &quot;x-env-value&quot;: &quot;ENTITY_IS_ALIVE&quot; } } }   tip You can use x-env-value to enable overriding the value of a field using environment variable. For more information check out the relevant docs in config and schemas.  If we want our service schema to extend the base boilerplate schema we could do this like that:  { &quot;$id&quot;: &quot;https://mapcolonies.com/my-domain/my-schema/v1&quot;, &quot;type&quot;: &quot;object&quot;, &quot;title&quot;: &quot;myDomainMySchemaV1&quot;, &quot;description&quot;: &quot;My domain's schema&quot;, &quot;allOf&quot;: [ { &quot;$ref&quot;: &quot;https://mapcolonies.com/common/boilerplate/v4&quot; }, { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;myDomain&quot;: { &quot;$ref&quot;: &quot;#/definitions/myDomainMySchemaV1&quot; } } } ], &quot;definitions&quot;: { &quot;myDomainMySchemaV1&quot;: { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;id&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;The unique identifier for the entity&quot; }, &quot;name&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;The name of the entity&quot; }, &quot;age&quot;: { &quot;type&quot;: &quot;integer&quot;, &quot;description&quot;: &quot;The age of the entity&quot;, &quot;x-env-value&quot;: &quot;ENTITY_AGE&quot; }, &quot;isAlive&quot;: { &quot;type&quot;: &quot;boolean&quot;, &quot;description&quot;: &quot;Is the entity alive&quot;, &quot;x-env-value&quot;: &quot;ENTITY_IS_ALIVE&quot; } } } } }    The result is a combined object with both the boilerplate schema and our own properties.  important When extending the boilerplate, you should check and make sure you extend the newest version. The version in this guide might be older.  ","version":"Next","tagName":"h2"},{"title":"Run validationsâ€‹","type":1,"pageTitle":"From Zero to Hero","url":"/docs/guides/config-management/zero-to-hero#run-validations","content":" We want to make sure that the schema are valid, therefore we need to check the schema for errors. To do so we can run the following command and make changes based on the feedback.  npm run validate   info To see all the validations check the following doc: https://github.com/MapColonies/schemas?tab=readme-ov-file#validations  ","version":"Next","tagName":"h2"},{"title":"Validating the typesâ€‹","type":1,"pageTitle":"From Zero to Hero","url":"/docs/guides/config-management/zero-to-hero#validating-the-types","content":" The types that the schemas package exports are automatically generated from the json schema. We want to make sure that the types are correct before we move forward. This way we can check the types and if anything is wrong go back and fix the schema.  Build the package:  npm run build   Check that the types are as you expected. They can be found under the build directory under the same hierarchy as the schema. For example, those are the types generated for the schema we created above extending the boilerplate schema:  build/schemas/my-domain/my-schema/v1.schema.d.ts import { typeSymbol } from '../../symbol.js'; declare const exported: { readonly [typeSymbol]: { [x: string]: unknown; myDomain?: { [x: string]: unknown; id?: string | undefined; name?: string | undefined; age?: number | undefined; isAlive?: boolean | undefined; } | undefined; openapiConfig: { [x: string]: unknown; filePath: string; basePath: string; rawPath: string; uiPath: string; }; telemetry: { [x: string]: unknown; logger: { [x: string]: unknown; level: &quot;info&quot; | &quot;trace&quot; | &quot;debug&quot; | &quot;warn&quot; | &quot;error&quot; | &quot;fatal&quot;; prettyPrint: boolean; }; shared: { [x: string]: unknown; serviceName?: string | undefined; serviceVersion?: string | undefined; hostname?: string | undefined; }; tracing: { [x: string]: unknown; debug?: boolean | undefined; url?: string | undefined; traceRatio?: number | undefined; isEnabled: boolean; }; }; server: { [x: string]: unknown; port: number; request: { [x: string]: unknown; payload: { [x: string]: unknown; limit: string; }; }; }; }; ...   note The rest of the file is important for the inner working of the schemas package. You should check only the types.  ","version":"Next","tagName":"h2"},{"title":"Checking integration with your serviceâ€‹","type":1,"pageTitle":"From Zero to Hero","url":"/docs/guides/config-management/zero-to-hero#checking-integration-with-your-service","content":" Before merging the changes you made, we want to make sure it works with your service.  install the development version of the schemas package into your service. There are multiple ways to achieve that, with some of them described below.  GithubLocal PathNPM PackOther Options When opening a PR in the schemas repo, the latest version of your branch will be built and be available for a week. Push your changes to the remote repository. git push --set-upstream origin &lt;my-branch-name&gt; Open a PR in the schemas repo.If all the validations pass, a comment will appear with instructions and link to the package.Insert the link into your service's package.json file. package.json { &quot;dependencies&quot;: { &quot;@map-colonies/schemas&quot;: &lt;insert-generated-link&gt; } } Install the package. npm install     Change the config in your service to use the new schema.  src/common/config.ts import { type ConfigInstance, config } from '@map-colonies/config'; import { &lt;your-new-schema&gt;, type [your-new-schema-type] } from '@map-colonies/schemas'; // Choose here the type of the config instance and import this type from the entire application type ConfigType = ConfigInstance&lt;[your-new-schema-type]&gt;; let configInstance: ConfigType | undefined; /** * Initializes the configuration by fetching it from the server. * This should only be called from the instrumentation file. * @returns A Promise that resolves when the configuration is successfully initialized. */ async function initConfig(offlineMode?:boolean): Promise&lt;void&gt; { configInstance = await config({ configName: 'boiler-config', configServerUrl: 'http://localhost:8080', schema: &lt;your-new-schema&gt;, version: 'latest', offlineMode: offlineMode }); }   Check that the service works as expected.  ","version":"Next","tagName":"h2"},{"title":"Next stepsâ€‹","type":1,"pageTitle":"From Zero to Hero","url":"/docs/guides/config-management/zero-to-hero#next-steps","content":" Now that you finished writing your schema, you can submit a PR to the schemas repo and ask for it to be reviewed.  We hope this guide was helpful and you were able to integrate the MapColoniesâ„¢ Config Management system into your service.  If you have any questions or need help, feel free to ask for help.  If you have any suggestions for this guide, please open a pull request. ","version":"Next","tagName":"h2"},{"title":"JSON Schema Tips","type":0,"sectionRef":"#","url":"/docs/knowledge-base/json-schema/json-schema-tips","content":"","keywords":"","version":"Next"},{"title":"Metadataâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#metadata","content":" You should use the title and description keywords to provide a description of the schema. This will help users understand what the schema is for.  { &quot;title&quot;: &quot;My Schema&quot;, &quot;description&quot;: &quot;This is a schema for my app&quot; }   ","version":"Next","tagName":"h2"},{"title":"Examplesâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#examples","content":" You can provide examples of how the schema should be used by using the examples keyword.  { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;string&quot; } }, &quot;examples&quot;: { &quot;name&quot;: &quot;John Doe&quot; } }   ","version":"Next","tagName":"h2"},{"title":"Commentsâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#comments","content":" You can use the $comment keyword to provide comments in the schema. This can be useful for providing additional information about the schema.  { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;string&quot; } }, &quot;$comment&quot;: &quot;This is a schema for my app&quot; }   For more information check the relevant JSON Schema Docs  ","version":"Next","tagName":"h2"},{"title":"Defaultâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#default","content":" When you have a default value for a property, you can use the default keyword to set it. This is useful for when you want to provide a default value for a property that is not required.  { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;default&quot;: &quot;John Doe&quot; } } }   The value will be provided by the config even if it is not set.  ","version":"Next","tagName":"h2"},{"title":"Requiredâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#required","content":" You can use the required keyword to specify which properties are required in the schema. By default, all properties are optional.  { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;string&quot; } }, &quot;required&quot;: [&quot;name&quot;] }   The types generated for the schema will reflect the required properties.  type MySchema = { name: string; };   ","version":"Next","tagName":"h2"},{"title":"Enumsâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#enums","content":" You can use the enum keyword to specify a list of possible values for a property. It is not required to specify the type of the property when using enum, so its possible for the enum to be of different types.  { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;color&quot;: { &quot;enum&quot;: [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] } } }   The types generated will be a union of the enum values.  type MySchema = { color: &quot;red&quot; | &quot;green&quot; | &quot;blue&quot;; };   ","version":"Next","tagName":"h2"},{"title":"Refsâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#refs","content":" You can use the $ref keyword to reference another schema. The references can be either internal or external.  Reference can be used to reuse schemas and keep the schema definitions clean. Even for small schemas like Id, it is a good practice to use refs.  ","version":"Next","tagName":"h2"},{"title":"Internal Refsâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#internal-refs","content":" { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;name&quot;: { &quot;$ref&quot;: &quot;#/definitions/name&quot; } }, &quot;definitions&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;string&quot; } } }   ","version":"Next","tagName":"h3"},{"title":"External Refsâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#external-refs","content":" External refs are only valid to other schemas that are defined in the schemas repository. The way to reference is to use the ID of required the schema.  { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;name&quot;: { &quot;$ref&quot;: &quot;https://mapcolonies.com/common/schema/v1&quot; } } }   ","version":"Next","tagName":"h3"},{"title":"Definitionsâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#definitions","content":" You can use the definitions keyword to define reusable schemas. The definitions are not part of the validated schema, unless they are referenced.  { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;name&quot;: { &quot;$ref&quot;: &quot;#/definitions/name&quot; } }, &quot;definitions&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;string&quot; } } }   ","version":"Next","tagName":"h2"},{"title":"Schema Compositionâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#schema-composition","content":" In many cases you will want to compose multiple schemas together. JSON Schema provides a few keywords to help with this. This way you can reuse schemas and keep the schema definitions clean.  The classic example in our case is to extends the boilerplate schema to fit our service.  For more information check the relevant JSON Schema Docs  ","version":"Next","tagName":"h2"},{"title":"AllOfâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#allof","content":" The allOf keyword is used to combine multiple schemas together. The properties of the schemas are merged together.  The following schema  { &quot;allOf&quot;: [ { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;string&quot; } } }, { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;age&quot;: { &quot;type&quot;: &quot;number&quot; } } } ] }   Will be equivalent to the following schema  { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;string&quot; }, &quot;age&quot;: { &quot;type&quot;: &quot;number&quot; } } }   important When using additionalProperties: false in the schemas, the allOf keyword will not merge the properties together. Instead, it will require that all properties are present in the schema, Which is not possible. Check the JSON Schema Docs for more information.  ","version":"Next","tagName":"h3"},{"title":"OneOfâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#oneof","content":" The oneOf keyword is used to specify that only one of the schemas should be valid.  The following schema  { &quot;oneOf&quot;: [ { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;string&quot; } } }, { &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;age&quot;: { &quot;type&quot;: &quot;number&quot; } } } ] }   If both properties are provided, the schema will be invalid.  ","version":"Next","tagName":"h3"},{"title":"Stringsâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#strings","content":" ","version":"Next","tagName":"h2"},{"title":"Formatsâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#formats","content":" It is recommended to use the format keyword to specify the format of the string. This will help users understand what the string is for and validate accordingly.  { &quot;type&quot;: &quot;string&quot;, &quot;format&quot;: &quot;email&quot; }   For a full list of formats check the ajv-formats repository.  ","version":"Next","tagName":"h3"},{"title":"Patternsâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#patterns","content":" You can use the pattern keyword to specify a regular expression that the string should match.  { &quot;type&quot;: &quot;string&quot;, &quot;pattern&quot;: &quot;^[a-zA-Z]+$&quot; }   ","version":"Next","tagName":"h3"},{"title":"Constâ€‹","type":1,"pageTitle":"JSON Schema Tips","url":"/docs/knowledge-base/json-schema/json-schema-tips#const","content":" You can use the const keyword to specify a constant value for the string.  { &quot;type&quot;: &quot;string&quot;, &quot;const&quot;: &quot;John Doe&quot; }  ","version":"Next","tagName":"h3"},{"title":"error-express-handler","type":0,"sectionRef":"#","url":"/docs/knowledge-base/packages/error-express-handler/","content":"","keywords":"","version":"Next"},{"title":"Installâ€‹","type":1,"pageTitle":"error-express-handler","url":"/docs/knowledge-base/packages/error-express-handler/#install","content":" npm install --save @map-colonies/error-express-handler   ","version":"Next","tagName":"h2"},{"title":"Usageâ€‹","type":1,"pageTitle":"error-express-handler","url":"/docs/knowledge-base/packages/error-express-handler/#usage","content":" import express from 'express'; import { getErrorHandlerMiddleware } from '@map-colonies/error-express-handler'; process.env.NODE_ENV = 'development'; const app = express(); app.use('/meow', fn); app.use(getErrorHandlerMiddleware()); app.listen(8080, function() { console.log('server is up'); });   ","version":"Next","tagName":"h2"},{"title":"Flowâ€‹","type":1,"pageTitle":"error-express-handler","url":"/docs/knowledge-base/packages/error-express-handler/#flow","content":"   note This page was generated from a remote source. you can find it on https://github.com/MapColonies/error-express-handler/blob/master/README.md ","version":"Next","tagName":"h2"},{"title":"Config","type":0,"sectionRef":"#","url":"/docs/knowledge-base/packages/config/","content":"","keywords":"","version":"Next"},{"title":"API Documentationâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#api-documentation","content":" This section describes the API provided by the package for interacting with the configuration.  ","version":"Next","tagName":"h2"},{"title":"ConfigInstance<T>â€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#configinstancet","content":" The ConfigInstance interface represents the your way to interact with the configuration. It provides methods to retrieve configuration values and parts.T is the typescript type associated with the chosen schema. it can be imported from the @map-colonies/schemas package.  Methodsâ€‹  get&lt;TPath extends string&gt;(path: TPath): _.GetFieldType&lt;T, TPath&gt;â€‹  Description: Retrieves the value at the specified path from the configuration object. Note that the type of returned object is based on the path in the schema.Parameters: path (TPath): The path to the desired value. Returns: The value at the specified path.  getAll(): Tâ€‹  Description: Retrieves the entire configuration object.Returns: The entire configuration object.  getConfigParts(): { localConfig: object; config: object; envConfig: object }â€‹  Description: Retrieves different parts of the configuration object before being merged and validated. Useful for debugging.Returns: An object containing the localConfig, config, and envConfig parts of the configuration. localConfig: The local configuration object.config: The remote configuration object.envConfig: The environment configuration object.  getResolvedOptions(): BaseOptionsâ€‹  Description: Retrieves the resolved options from the configuration object. Useful for debugging.Returns: The resolved options, which are an instance of BaseOptions.  Configuration Options  This package allows you to configure various options for loading and managing configurations. Below are the available options and their descriptions.  ","version":"Next","tagName":"h3"},{"title":"Optionsâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#options","content":" ","version":"Next","tagName":"h2"},{"title":"schemaâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#schema","content":" Type: T extends SchemaWithTypeOptional: falseDescription: The schema of the configuration object.  ","version":"Next","tagName":"h3"},{"title":"configNameâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#configname","content":" Type: stringOptional: falseDescription: The name of the remote configuration.Environment Variable: CONFIG_NAME  ","version":"Next","tagName":"h3"},{"title":"versionâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#version","content":" Type: 'latest' | numberOptional: falseDescription: The version of the remote configuration. It can be either 'latest' or a number.Environment Variable: CONFIG_VERSION  ","version":"Next","tagName":"h3"},{"title":"configServerUrlâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#configserverurl","content":" Type: stringOptional: falseDescription: The URL of the configuration server.Environment Variable: CONFIG_SERVER_URL  ","version":"Next","tagName":"h3"},{"title":"offlineModeâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#offlinemode","content":" Type: booleanOptional: trueDefault: falseDescription: Indicates whether the configuration should be loaded in offline mode.Environment Variable: CONFIG_OFFLINE_MODE  ","version":"Next","tagName":"h3"},{"title":"ignoreServerIsOlderVersionErrorâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#ignoreserverisolderversionerror","content":" Type: booleanOptional: trueDescription: Indicates whether to ignore the error when the server version is older than the requested version.Environment Variable: CONFIG_IGNORE_SERVER_IS_OLDER_VERSION_ERROR  ","version":"Next","tagName":"h3"},{"title":"localConfigPathâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#localconfigpath","content":" Type: stringOptional: trueDefault: ./configDescription: The path to the local configuration folder.  ","version":"Next","tagName":"h3"},{"title":"JSON Schemaâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#json-schema","content":" The options are validated against the following JSON schema:  { &quot;required&quot;: [&quot;configName&quot;, &quot;configServerUrl&quot;, &quot;version&quot;], &quot;additionalProperties&quot;: false, &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: { &quot;configName&quot;: { &quot;type&quot;: &quot;string&quot; }, &quot;version&quot;: { &quot;oneOf&quot;: [ { &quot;type&quot;: &quot;string&quot;, &quot;const&quot;: &quot;latest&quot; }, { &quot;type&quot;: &quot;integer&quot;, &quot;minimum&quot;: 1 } ] }, &quot;configServerUrl&quot;: { &quot;type&quot;: &quot;string&quot; }, &quot;offlineMode&quot;: { &quot;type&quot;: &quot;boolean&quot;, &quot;nullable&quot;: true }, &quot;ignoreServerIsOlderVersionError&quot;: { &quot;type&quot;: &quot;boolean&quot;, &quot;nullable&quot;: true }, &quot;localConfigPath&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;default&quot;: &quot;./config&quot; } } }   ","version":"Next","tagName":"h2"},{"title":"Environment Variable Configurationâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#environment-variable-configuration","content":" The following environment variables can be used to configure the options:  CONFIG_NAME: Sets the configName option.CONFIG_VERSION: Sets the version option.CONFIG_SERVER_URL: Sets the configServerUrl option.CONFIG_OFFLINE_MODE: Sets the offlineMode option.CONFIG_IGNORE_SERVER_IS_OLDER_VERSION_ERROR: Sets the ignoreServerIsOlderVersionError option.  ","version":"Next","tagName":"h2"},{"title":"Configuration Merging and Validationâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#configuration-merging-and-validation","content":" The package supports merging configurations from multiple sources (local, remote, and environment variables) and then validates the merged configuration against the schema.  ","version":"Next","tagName":"h2"},{"title":"Local Configurationâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#local-configuration","content":" The local configuration is loaded from the path specified by the localConfigPath option. The default path is ./config.  ","version":"Next","tagName":"h3"},{"title":"Remote Configurationâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#remote-configuration","content":" The remote configuration is fetched from the server specified by the configServerUrl option.If the version is set to 'latest', the latest version of the configuration is fetched. Otherwise, the specified version is fetched.  ","version":"Next","tagName":"h3"},{"title":"Environment Variablesâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#environment-variables","content":" Configuration options can be overridden by setting the corresponding environment variables as described in schema using the x-env-value key.  ","version":"Next","tagName":"h3"},{"title":"Merging Configurationsâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#merging-configurations","content":" The configurations are merged in the following order of precedence: Environment variablesRemote configurationLocal configuration If a configuration option is specified in multiple sources, the value from the source with higher precedence (as listed above) is used.  ","version":"Next","tagName":"h3"},{"title":"Validationâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#validation","content":" After merging, the final configuration is validated against the defined schema using ajv.The validation ensures that all required properties are present, and the types and values of properties conform to the schema.Any default value according to the schema is added to the final object.If the validation fails, an error is thrown, indicating the invalid properties and their issues.  Error handling  This section describes the possible errors that can occur when using the package, along with their codes and payload structures.  ","version":"Next","tagName":"h3"},{"title":"Identifying errorsâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#identifying-errors","content":" The package exposes a helper function called isConfigError to assert what is the error that was thrown and handle it as needed.  import { config, isConfigError } from '@map-colonies/config'; try { const configInstance = await config({ configName: 'boiler-config', configServerUrl: 'http://localhost:8080', schema: commonBoilerplateV4, version: 'latest', offlineMode: false }); } catch (error) { if (isConfigError(error, 'configValidationError')) { console.error('Config validation error:', error.payload); } }   ","version":"Next","tagName":"h2"},{"title":"Errorsâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#errors","content":" ","version":"Next","tagName":"h2"},{"title":"optionValidationErrorâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#optionvalidationerror","content":" Code: 1Payload: ValidationError[]Description: This error occurs when there is a validation error with one of the configuration options.  ","version":"Next","tagName":"h3"},{"title":"configValidationErrorâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#configvalidationerror","content":" Code: 2Payload: ValidationError[]Description: This error occurs when the configuration as a whole fails validation.  ","version":"Next","tagName":"h3"},{"title":"httpResponseErrorâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#httpresponseerror","content":" Code: 3Payload: { headers: Record&lt;string, string&gt;; statusCode: number; body: string; } Description: This error occurs when an HTTP request results in an error response. The payload includes the response headers, status code and body.  ","version":"Next","tagName":"h3"},{"title":"httpGeneralErrorâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#httpgeneralerror","content":" Code: 4Payload: ErrorDescription: This error occurs when there is a general HTTP error. The payload contains the error object.  ","version":"Next","tagName":"h3"},{"title":"schemaNotFoundErrorâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#schemanotfounderror","content":" Code: 5Payload: { schemaPath: string; } Description: This error occurs when the specified schema cannot be found. The payload includes the path of the missing schema.  ","version":"Next","tagName":"h3"},{"title":"schemasPackageVersionMismatchErrorâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#schemaspackageversionmismatcherror","content":" Code: 6Payload: { remotePackageVersion: string; localPackageVersion: string; } Description: This error occurs when there is a version mismatch between the remote and local schema packages. The payload includes the versions of both the remote and local packages.  ","version":"Next","tagName":"h3"},{"title":"schemaVersionMismatchErrorâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#schemaversionmismatcherror","content":" Code: 7Payload: { remoteSchemaVersion: string; localSchemaVersion: string; } Description: This error occurs when there is a version mismatch between the remote and local schemas. The payload includes the versions of both the remote and local schemas.  Debugging  If for some reason you want to debug the package you can either use the getConfigParts or the getResolvedOptions functions described in the API or use the more powerful debug logger.  The package debug logger is implemented using the debug npm package and is configured using the DEBUG Environment variable.  The following are the values you can configure to use the debug option.  ","version":"Next","tagName":"h3"},{"title":"DEBUG=*â€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#debug","content":" Enables all the logs. Note that setting this option might enable debug logging of other packages.  ","version":"Next","tagName":"h3"},{"title":"DEBUG=@map-colonies/config*â€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#debugmap-coloniesconfig","content":" Enables all the logs available in this package.  ","version":"Next","tagName":"h3"},{"title":"DEBUG=@map-colonies/config:configâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#debugmap-coloniesconfigconfig","content":" Enables only the logs related to the main logic of the package.  ","version":"Next","tagName":"h3"},{"title":"DEBUG=@map-colonies/config:envâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#debugmap-coloniesconfigenv","content":" Enables only the logs related to parsing environment variables from schemas, and retrieving them for use in the configuration.  ","version":"Next","tagName":"h3"},{"title":"DEBUG=@map-colonies/config:httpâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#debugmap-coloniesconfighttp","content":" Enables only the logs related to http requests to the config-server.  ","version":"Next","tagName":"h3"},{"title":"DEBUG=@map-colonies/config:optionsâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#debugmap-coloniesconfigoptions","content":" Enables only the logs related to parsing and validation of the package initialization options.  ","version":"Next","tagName":"h3"},{"title":"DEBUG=@map-colonies/config:schemasâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#debugmap-coloniesconfigschemas","content":" Enables only the logs related to the retrieving of schemas.  ","version":"Next","tagName":"h3"},{"title":"DEBUG=@map-colonies/config:validatorâ€‹","type":1,"pageTitle":"Config","url":"/docs/knowledge-base/packages/config/#debugmap-coloniesconfigvalidator","content":" Enables only the logs related to the validation of configurations.  note This page was generated from a remote source. you can find it on https://github.com/MapColonies/config/blob/master/README.md ","version":"Next","tagName":"h3"},{"title":"Map Colonies ESLint configs","type":0,"sectionRef":"#","url":"/docs/knowledge-base/packages/eslint-config/","content":"","keywords":"","version":"Next"},{"title":"Available Configsâ€‹","type":1,"pageTitle":"Map Colonies ESLint configs","url":"/docs/knowledge-base/packages/eslint-config/#available-configs","content":" ts-base: base configurations for typescript.react: rules for react (extends react-app).jest: rules for jest.  ","version":"Next","tagName":"h2"},{"title":"Installationâ€‹","type":1,"pageTitle":"Map Colonies ESLint configs","url":"/docs/knowledge-base/packages/eslint-config/#installation","content":" $ npm install --save-dev eslint @map-colonies/eslint-config   or  $ yarn add --dev eslint @map-colonies/eslint-config   ","version":"Next","tagName":"h2"},{"title":"Usageâ€‹","type":1,"pageTitle":"Map Colonies ESLint configs","url":"/docs/knowledge-base/packages/eslint-config/#usage","content":" Add the configs you want to the extend section of your eslintConfig of your package.json, or to your .eslintrc configuration file. Note: make sure to add ts-base last.   &quot;eslintConfig&quot;: { &quot;extends&quot;: [ &quot;@map-colonies/eslint-config/react&quot;, &quot;@map-colonies/eslint-config/ts-base&quot; ] }   Then add the path to your TypeScript configuration file to the parserOptions  &quot;eslintConfig&quot;: { &quot;parserOptions&quot;: { &quot;project&quot;: &quot;./path/to/your/tsconfig.json&quot; } }   ","version":"Next","tagName":"h2"},{"title":"Adding new Configsâ€‹","type":1,"pageTitle":"Map Colonies ESLint configs","url":"/docs/knowledge-base/packages/eslint-config/#adding-new-configs","content":" Add a new file and name it as you would like. Inside export the ESLint configuration.  module.exports = { extends: ['plugin:jest/recommended', 'plugin:jest/style'], plugins: ['jest'], env: { 'jest/globals': true, }, };   after you finished developing the config, make sure it works by using the --print-config flag of ESLint, in the project you use for testing.  $ npx eslint --print-config index.ts   Dont forget adding the config to this readme ðŸ˜Š  ","version":"Next","tagName":"h2"},{"title":"Issuesâ€‹","type":1,"pageTitle":"Map Colonies ESLint configs","url":"/docs/knowledge-base/packages/eslint-config/#issues","content":" If any linting error is appearing twice, or you have any other problem, please open an issue with all the details you have.  note This page was generated from a remote source. you can find it on https://github.com/MapColonies/eslint-config/blob/master/README.md ","version":"Next","tagName":"h2"},{"title":"js logger","type":0,"sectionRef":"#","url":"/docs/knowledge-base/packages/js-logger/","content":"","keywords":"","version":"Next"},{"title":"Usageâ€‹","type":1,"pageTitle":"js logger","url":"/docs/knowledge-base/packages/js-logger/#usage","content":" import jsLogger from '@map-colonies/js-logger'; const logger = jsLogger(); logger.info('hello world'); logger.error({hello: 'world'});   for more detailed usage check the pino documentation.  ","version":"Next","tagName":"h2"},{"title":"Configurationâ€‹","type":1,"pageTitle":"js logger","url":"/docs/knowledge-base/packages/js-logger/#configuration","content":" name\ttype\tdefault value\tdescriptionenabled\tboolean\ttrue\tenables logging level\tstring\t'info'\tone of the supported level or silent to disable logging prettyPrint\tboolean\tfalse\tpretty print for developing purposes redact\tarray\tundefined\tarray of paths in object to be redacted from the log destination\tnumber / string\t1\tThe stream to send the log to, or file base\tobject\t{pid: process.pid, hostname: os.hostname}\tKey-value object added as child logger to each log line pinoCaller\tboolean\tfalse\tadds the call site of each log message to the log output  note This page was generated from a remote source. you can find it on https://github.com/MapColonies/js-logger/blob/master/README.md ","version":"Next","tagName":"h2"},{"title":"express-access-log-middleware","type":0,"sectionRef":"#","url":"/docs/knowledge-base/packages/express-access-log-middleware/","content":"","keywords":"","version":"Next"},{"title":"ts-npm-package-boilerplate","type":0,"sectionRef":"#","url":"/docs/knowledge-base/packages/openapi-express-viewer/","content":"ts-npm-package-boilerplate After cloning this template, please do the following: insert secrets to repo secrets for the github actions.replace every string &quot;ts-npm-package-boilerplate&quot; with your package name. note This page was generated from a remote source. you can find it on https://github.com/MapColonies/openapi-express-viewer/blob/master/README.md","keywords":"","version":"Next"},{"title":"Usageâ€‹","type":1,"pageTitle":"express-access-log-middleware","url":"/docs/knowledge-base/packages/express-access-log-middleware/#usage","content":" import * as express from 'express'; import jsLogger from '@map-colonies/js-logger'; import httpLogger from '@map-colonies/express-access-log-middleware'; const app = express() const logger = jsLogger(); app.use(jsLogger({logger})); app.get('/', (req,res) =&gt; { res.json(hello: 'world'); }); app.listen(8080);   for more detailed usage check the pino-http documentation.  ","version":"Next","tagName":"h2"},{"title":"Configurationâ€‹","type":1,"pageTitle":"express-access-log-middleware","url":"/docs/knowledge-base/packages/express-access-log-middleware/#configuration","content":" name\ttype\tdefault value\tdescriptionlogger\tLogger The logger instance to use ignorePaths\tstring[]\tundefined\tThe paths to ignore logging customLogLevel\t(res, err) =&gt; log_level\tinfo for all under 500 status\tA function to set the log level of a request customSuccessMessage\t(res: ServerResponse) =&gt; string\tundefined\tfunction to set the success message customErrorMessage\t(error: Error, res: ServerResponse) =&gt; string\tundefined\tfunction to set the success message  note This page was generated from a remote source. you can find it on https://github.com/MapColonies/express-access-log-middleware/blob/master/README.md ","version":"Next","tagName":"h2"},{"title":"prettier-config","type":0,"sectionRef":"#","url":"/docs/knowledge-base/packages/prettier-config/","content":"prettier-config After cloning this template, please do the following: insert secrets to repo secrets for the github actions.replace every string &quot;prettier-config&quot; with your package name. note This page was generated from a remote source. you can find it on https://github.com/MapColonies/prettier-config/blob/master/README.md","keywords":"","version":"Next"},{"title":"read-pkg","type":0,"sectionRef":"#","url":"/docs/knowledge-base/packages/read-pkg/","content":"read-pkg After cloning this template, please do the following: insert secrets to repo secrets for the github actions.replace every string &quot;read-pkg&quot; with your package name. note This page was generated from a remote source. you can find it on https://github.com/MapColonies/read-pkg/blob/master/README.md","keywords":"","version":"Next"},{"title":"openapi-helpers","type":0,"sectionRef":"#","url":"/docs/knowledge-base/packages/openapi-helpers/","content":"","keywords":"","version":"Next"},{"title":"Installationâ€‹","type":1,"pageTitle":"openapi-helpers","url":"/docs/knowledge-base/packages/openapi-helpers/#installation","content":" Run the following commands:  npm install --save-dev @map-colonies/openapi-helpers supertest prettier openapi-typescript @types/express   ","version":"Next","tagName":"h2"},{"title":"types-generatorâ€‹","type":1,"pageTitle":"openapi-helpers","url":"/docs/knowledge-base/packages/openapi-helpers/#types-generator","content":" The package contains a script that wraps the openapi-typescript package and generates types for the openapi schema. The script also formats the generated types using prettier.  The command structure is as follows:  npx @map-colonies/openapi-helpers &lt;input-file&gt; &lt;output-file&gt; --format --add-typed-request-handler   For example:  npx @map-colonies/openapi-helpers ./openapi3.yaml ./src/openapi.d.ts --format --add-typed-request-handler   ","version":"Next","tagName":"h2"},{"title":"optionsâ€‹","type":1,"pageTitle":"openapi-helpers","url":"/docs/knowledge-base/packages/openapi-helpers/#options","content":" --format - format the generated types using prettier.--add-typed-request-handler - add the TypedRequestHandler type to the generated types.  ","version":"Next","tagName":"h3"},{"title":"TypedRequestHandlerâ€‹","type":1,"pageTitle":"openapi-helpers","url":"/docs/knowledge-base/packages/openapi-helpers/#typedrequesthandler","content":" The package contains a wrapper for the express types package that provides autocomplete for all the request Handlers to the API based on the openapi. The TypedRequestHandler is initialized with the the typed generated by openapi-typescript, and is configured based on operation name or method and path.  ","version":"Next","tagName":"h2"},{"title":"Usageâ€‹","type":1,"pageTitle":"openapi-helpers","url":"/docs/knowledge-base/packages/openapi-helpers/#usage","content":" import { TypedRequestHandlers } from '@map-colonies/openapi-helpers/typedRequestHandler'; import type { paths, operations } from './src/openapi.d.ts'; // Initialize the TypedRequestHandlers with the paths and operations types // This can be done in a separate file and exported, in the same file or even in the same line type MyHandlers = TypedRequestHandlers&lt;paths, operations&gt;; export class Controller { // Define the handler for the operation based method and path public getResource: MyHandlers['GET /resource'] = (req, res) =&gt; { res.status(httpStatus.OK).json({id: 1, description: 'description', name: 'name'}); }; // Define the handler for the operation based on the operation name public getResource: MyHandlers['getResource'] = (req, res) =&gt; { res.status(httpStatus.OK).json({id: 1, description: 'description', name: 'name'}); }; }   ","version":"Next","tagName":"h3"},{"title":"RequestSenderâ€‹","type":1,"pageTitle":"openapi-helpers","url":"/docs/knowledge-base/packages/openapi-helpers/#requestsender","content":" The package contains a wrapper for the supertest package that provides autocomplete for all the requests to the API based on the openapi. The requestSender is initialized with the server's base url and the openapi schema and the types exported by openapi-typescript.  import { RequestSender } from '@map-colonies/openapi-helpers/requestSender'; import type { paths, operations } from './src/openapi.d.ts'; const requestSender = await createRequestSender&lt;paths, operations&gt;('path/to/openapi3.yaml', expressApp);   The requestSender object contains all the paths and operations defined in the openapi schema. For example, to send a request to the getUsers operation with the /users path and with the GET method, you can use the following code:  const response = await requestSender.getUsers(); // or const response = await requestSender.sendRequest({ method: 'get', path: '/simple-request' });   The package supports all the operations defined in the openapi schema, either by operation name, or by using the sendRequest function with the method, path and parameters.  [!IMPORTANT] For the package function properly, you need to make sure that the following values are configured in your tsconfig.json or jsconfig.json files under compilerOptions: module: &quot;NodeNext&quot;moduleResolution: &quot;NodeNext&quot;  note This page was generated from a remote source. you can find it on https://github.com/MapColonies/openapi-helpers/blob/master/README.md ","version":"Next","tagName":"h2"},{"title":"tsconfig","type":0,"sectionRef":"#","url":"/docs/knowledge-base/packages/tsconfig/","content":"","keywords":"","version":"Next"},{"title":"Installâ€‹","type":1,"pageTitle":"tsconfig","url":"/docs/knowledge-base/packages/tsconfig/#install","content":" npm install --save-dev @map-colonies/tsconfig   The config requires TypeScript 5.5 or later.  ","version":"Next","tagName":"h2"},{"title":"Usageâ€‹","type":1,"pageTitle":"tsconfig","url":"/docs/knowledge-base/packages/tsconfig/#usage","content":" tsconfig.json  { &quot;extends&quot;: &quot;@map-colonies/tsconfig/&lt;wanted tsconfig file&gt;&quot; }   ","version":"Next","tagName":"h2"},{"title":"Available filesâ€‹","type":1,"pageTitle":"tsconfig","url":"/docs/knowledge-base/packages/tsconfig/#available-files","content":" tsconfig-app.json - For use in services like ts-server-boilerplatetsconfig-library.json - For use in libraries published top npmtsconfig-base.json - The base tsconfig file  note This page was generated from a remote source. you can find it on https://github.com/MapColonies/tsconfig/blob/master/README.md ","version":"Next","tagName":"h2"},{"title":"Telemetry","type":0,"sectionRef":"#","url":"/docs/knowledge-base/packages/telemetry/","content":"","keywords":"","version":"Next"},{"title":"Motiveâ€‹","type":1,"pageTitle":"Telemetry","url":"/docs/knowledge-base/packages/telemetry/#motive","content":" This package goal is to make the experience of configuring and working with OpenTelemetry easier.  ","version":"Next","tagName":"h2"},{"title":"Manual for easy local grafana deploymentâ€‹","type":1,"pageTitle":"Telemetry","url":"/docs/knowledge-base/packages/telemetry/#manual-for-easy-local-grafana-deployment","content":" ","version":"Next","tagName":"h2"},{"title":"exampleâ€‹","type":1,"pageTitle":"Telemetry","url":"/docs/knowledge-base/packages/telemetry/#example","content":" Below are short examples for tracing and metrics. More examples are available at the examples folder, and the various opentelemetry repos.  ","version":"Next","tagName":"h2"},{"title":"Tracingâ€‹","type":1,"pageTitle":"Telemetry","url":"/docs/knowledge-base/packages/telemetry/#tracing","content":" The following code shows a simple example of how to work with tracing. please notice that you need to manually install any auto-instrumentation library that you require.  import { Tracing } from '@map-colonies/telemetry'; import { trace } from '@opentelemetry/api'; const tracing = new Tracing(); tracing.start(); const tracer = trace.getTracer('tracing-name') const span = tracer.startSpan('some-action'); span.setAttribute('some-attribute'); // DO STUFF span.end(); tracing.stop().then(() =&gt; console.log('done'));   Another way for initialize tracing with custom resource:  import { Tracing } from '@map-colonies/telemetry'; import { Resource } from '@opentelemetry/resources'; const resource = new Resource({ 'service.version': number, 'service.name': 'my-service-name' }); const tracing = new Tracing([], resource); ...   ","version":"Next","tagName":"h3"},{"title":"Metricsâ€‹","type":1,"pageTitle":"Telemetry","url":"/docs/knowledge-base/packages/telemetry/#metrics","content":" The following code shows a simple example of how to work with metrics.  import { Metrics } from '@map-colonies/telemetry'; const metrics = new Metrics('sample-meter'); const meter = metrics.start(); const counter = meter.createCounter('sample_counter'); counter.add(1); metrics.stop().then(() =&gt; console.log('done'));   ","version":"Next","tagName":"h3"},{"title":"Semantic Conventionsâ€‹","type":1,"pageTitle":"Telemetry","url":"/docs/knowledge-base/packages/telemetry/#semantic-conventions","content":" The package's Semantic Conventions submodule defines a common set of (semantic) attributes which provide meaning to data when collecting, producing and consuming it.â€‹  Based on the official OpenTelemetry conventions  Link to full documentation  ","version":"Next","tagName":"h2"},{"title":"Configurationâ€‹","type":1,"pageTitle":"Telemetry","url":"/docs/knowledge-base/packages/telemetry/#configuration","content":" ","version":"Next","tagName":"h2"},{"title":"Common configurationâ€‹","type":1,"pageTitle":"Telemetry","url":"/docs/knowledge-base/packages/telemetry/#common-configuration","content":" name\tallowed value\tdefault value\tdescriptionTELEMETRY_SERVICE_NAME\tstring\tfrom package.json\tThe service name TELEMETRY_SERVICE_VERSION\tstring\tfrom package.json\tThe service version TELEMETRY_HOST_NAME\tstring\tos.hostname()\tThe host name    ","version":"Next","tagName":"h3"},{"title":"Tracing configurationâ€‹","type":1,"pageTitle":"Telemetry","url":"/docs/knowledge-base/packages/telemetry/#tracing-configuration","content":" name\tallowed value\tdefault value\tdescriptionTELEMETRY_TRACING_ENABLED\t'true', 'false'\t'false'\tShould Tracing be enabled TELEMETRY_TRACING_URL*\tstring\thttp://localhost:4318/v1/traces\tThe URL to the OpenTelemetry Collector TELEMETRY_TRACING_RATIO\tfloat\t1\tThe amount of traces to sample  * required (only when tracing is enabled).   ","version":"Next","tagName":"h3"},{"title":"Metric configurationâ€‹","type":1,"pageTitle":"Telemetry","url":"/docs/knowledge-base/packages/telemetry/#metric-configuration","content":" name\tallowed value\tdefault value\tdescriptionTELEMETRY_METRICS_ENABLED\t'true', 'false'\t'false'\tShould Metrics be enabled TELEMETRY_METRICS_URL*\tstring\thttp://localhost:4318/v1/metrics\tThe URL to the OpenTelemetry Collector TELEMETRY_METRICS_INTERVAL\tnumber\t15000\tThe interval in miliseconds between sending data to the collector  * required (only when tracing is enabled).  ","version":"Next","tagName":"h3"},{"title":"How to releaseâ€‹","type":1,"pageTitle":"Telemetry","url":"/docs/knowledge-base/packages/telemetry/#how-to-release","content":" Run the command npm run release -- to bump the version in all the files and create a changelog.  For more detailed documentation and examples check: https://github.com/conventional-changelog/standard-version  note This page was generated from a remote source. you can find it on https://github.com/MapColonies/telemetry/blob/master/README.md ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}